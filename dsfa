# main2.py
# This file will contain the main logic for the LINE Bot and backend.

from flask import Flask, request, abort, redirect, url_for, session # Added redirect, url_for, session
import os
from dotenv import load_dotenv
from google.oauth2 import service_account
from googleapiclient.discovery import build
from googleapiclient.http import MediaFileUpload, MediaIoBaseUpload # Import MediaIoBaseUpload
import traceback 
import sys # Import sys module
import math # For Haversine distance calculation
from datetime import datetime # For timestamp
import uuid # For unique IDs
import io # Import io module
# import imghdr # REMOVED imghdr
from PIL import Image # Import Pillow for image type detection

# OAuth imports
from google.oauth2.credentials import Credentials # Added
from google_auth_oauthlib.flow import Flow
from google.auth.transport.requests import Request
import pickle # For storing token.pickle
import os.path # For checking token.pickle file
import json # For saving token.json
import pathlib # For checking token.json path

# Use v3 models for compatibility with newer SDK versions
from linebot.v3.messaging import (
    Configuration, ApiClient, MessagingApi, ReplyMessageRequest,
    TextMessage as V3TextMessage,
    MessagingApiBlob # Import MessagingApiBlob
) 
from linebot.v3.webhooks import MessageEvent, TextMessageContent, ImageMessageContent, LocationMessageContent
from linebot.v3.webhook import WebhookHandler
from linebot.v3.exceptions import InvalidSignatureError # Keep this for webhook handling

# Load environment variables from .env file
load_dotenv()
print(f"DEBUG: GOOGLE_SHEET_ID from os.getenv: {os.getenv('GOOGLE_SHEET_ID')}")
print(f"DEBUG: GOOGLE_DRIVE_FOLDER_ID from os.getenv: {os.getenv('GOOGLE_DRIVE_FOLDER_ID')}")
print(f"DEBUG: FLASK_SECRET_KEY from os.getenv: {os.getenv('FLASK_SECRET_KEY')}")
print(f"DEBUG: GOOGLE_CLIENT_ID from os.getenv: {os.getenv('GOOGLE_CLIENT_ID')}")
print(f"DEBUG: GOOGLE_CLIENT_SECRET from os.getenv: {os.getenv('GOOGLE_CLIENT_SECRET')}")
print(f"DEBUG: GOOGLE_REDIRECT_URI from os.getenv: {os.getenv('GOOGLE_REDIRECT_URI')}")
sys.stdout.flush()

# --- Flask App Initialization ---
app = Flask(__name__) 
app.secret_key = os.getenv("FLASK_SECRET_KEY", "dev-secret-change-me") # Required for Flask sessions

# Apply ProxyFix for ngrok/proxy support
from werkzeug.middleware.proxy_fix import ProxyFix
app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)
app.config['PREFERRED_URL_SCHEME'] = 'https'

# --- Google API Configuration ---
# OAuth Scopes for Drive access
OAUTH_SCOPES = [
    'https://www.googleapis.com/auth/drive.file', # Access to files created or opened by the app
    'https://www.googleapis.com/auth/drive.appdata', # Access to the application data folder
    'https://www.googleapis.com/auth/drive.metadata.readonly' # Read-only access to file metadata
]

# Service Account Scopes (for Sheets, if still used)
SERVICE_ACCOUNT_SCOPES = [
    'https://www.googleapis.com/auth/spreadsheets'
]
SERVICE_ACCOUNT_FILE = 'credentials.json' # Make sure this file is in the same directory as main.py

# --- Google Sheets Configuration ---
SPREADSHEET_ID = os.getenv('GOOGLE_SHEET_ID') # You need to set this in your .env file
print(f"DEBUG: SPREADSHEET_ID assigned: {SPREADSHEET_ID}") # New print
sys.stdout.flush()

# --- Google Drive Configuration (OAuth) ---
# These will be used for OAuth flow
GOOGLE_CLIENT_ID = os.getenv('GOOGLE_CLIENT_ID')
GOOGLE_CLIENT_SECRET = os.getenv('GOOGLE_CLIENT_SECRET')
GOOGLE_REDIRECT_URI = os.getenv('GOOGLE_REDIRECT_URI')

# Validate GOOGLE_REDIRECT_URI for HTTPS
if GOOGLE_REDIRECT_URI and not GOOGLE_REDIRECT_URI.startswith("https://"):
    raise ValueError("GOOGLE_REDIRECT_URI must use HTTPS (e.g., https://your-ngrok-url/oauth2callback)")

TOKEN_PATH = "token.json" # Path to store OAuth token
CLIENT_SECRETS_FILE = "client_secret.json" # Path to client_secret.json downloaded from Cloud Console
print(f"DEBUG: CLIENT_SECRETS_FILE path: {os.path.abspath(CLIENT_SECRETS_FILE)}") # New print
sys.stdout.flush()

# Global variables for Google services
sheets_service = None
drive_service = None

def get_drive_service_oauth():
    """Authenticates with Google using OAuth 2.0 and returns Drive service object."""
    creds = None
    if pathlib.Path(TOKEN_PATH).exists():
        creds = Credentials.from_authorized_user_file(TOKEN_PATH, OAUTH_SCOPES)

    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            # No valid creds, user needs to authorize via /authorize route
            print("DEBUG: No valid OAuth credentials found. User needs to authorize.")
            sys.stdout.flush()
            return None
    
    # Save the credentials for the next run
    with open(TOKEN_PATH, 'w') as f:
        f.write(creds.to_json())

    return build('drive', 'v3', credentials=creds)

def get_google_service_sheets():
    """Authenticates with Google using a service account for Sheets access."""
    try:
        creds = service_account.Credentials.from_service_account_file(
            SERVICE_ACCOUNT_FILE, scopes=SERVICE_ACCOUNT_SCOPES)
        return build('sheets', 'v4', credentials=creds)
    except Exception as e:
        print(f"Error initializing Google Sheets service account: {e}")
        traceback.print_exc()
        sys.stdout.flush()
        return None

def ensure_google_services(): # Modified to handle both OAuth and Service Account
    """Ensures Google Sheets and Drive services are initialized."""
    global sheets_service, drive_service
    if sheets_service is None:
        sheets_service = get_google_service_sheets()
        if sheets_service is None:
            print("ERROR: Failed to initialize Google Sheets service. Aborting.")
            sys.stdout.flush()
            abort(500)
    
    if drive_service is None:
        drive_service = get_drive_service_oauth()
        if drive_service is None:
            print("ERROR: Google Drive service not authorized. Please authorize via /authorize.")
            sys.stdout.flush()
            # We don't abort here, but expect the bot to handle cases where Drive is not ready.

# --- LINE Bot Configuration ---
LINE_CHANNEL_ACCESS_TOKEN = os.getenv('LINE_CHANNEL_ACCESS_TOKEN')
LINE_CHANNEL_SECRET = os.getenv('LINE_CHANNEL_SECRET')

if not LINE_CHANNEL_ACCESS_TOKEN:
    raise ValueError("LINE_CHANNEL_ACCESS_TOKEN not set in .env")
if not LINE_CHANNEL_SECRET:
    raise ValueError("LINE_CHANNEL_SECRET not set in .env")

# OAuth Client ID/Secret/Redirect URI checks
if not GOOGLE_CLIENT_ID or not GOOGLE_CLIENT_SECRET or not GOOGLE_REDIRECT_URI:
    print("WARNING: Google OAuth Client ID, Secret, or Redirect URI not fully set in .env. OAuth flow may fail.")
    sys.stdout.flush()

# Initialize LINE Messaging API client (v3)
configuration = Configuration(access_token=LINE_CHANNEL_ACCESS_TOKEN)
line_bot_api = MessagingApi(ApiClient(configuration))
handler = WebhookHandler(LINE_CHANNEL_SECRET)
blob_api = MessagingApiBlob(ApiClient(configuration)) # Initialize MessagingApiBlob

print("LINE Bot API and Webhook Handler initialized.")
sys.stdout.flush() # Flush output

# --- Google Sheets Helper Functions ---
def get_sheet_data(sheet_name):
    """Reads all data from a specified sheet."""
    print(f"DEBUG: Attempting to read from sheet: {sheet_name}")
    sys.stdout.flush()
    try:
        result = sheets_service.spreadsheets().values().get(
            spreadsheetId=SPREADSHEET_ID, range=sheet_name).execute()
        data = result.get('values', [])
        print(f"DEBUG: Successfully read {len(data)} rows from {sheet_name}.")
        sys.stdout.flush()
        return data
    except Exception as e:
        print(f"ERROR: Error reading from sheet {sheet_name}: {e}")
        traceback.print_exc()
        sys.stdout.flush()
        return []

def append_sheet_data(sheet_name, values):
    """Appends a row of data to a specified sheet."""
    print(f"DEBUG: Attempting to append to sheet: {sheet_name} with values: {values}")
    sys.stdout.flush()
    try:
        body = {'values': [values]}
        result = sheets_service.spreadsheets().values().append(
            spreadsheetId=SPREADSHEET_ID, range=sheet_name,
            valueInputOption='RAW', body=body).execute()
        print(f"DEBUG: Successfully appended to {sheet_name}.")
        sys.stdout.flush()
        return result
    except Exception as e:
        print(f"ERROR: Error appending to sheet {sheet_name}: {e}")
        traceback.print_exc()
        sys.stdout.flush()
        return None

def update_sheet_data(sheet_name, range_name, values):
    """Updates data in a specified range of a sheet."""
    print(f"DEBUG: Attempting to update sheet: {sheet_name} range: {range_name} with values: {values}")
    sys.stdout.flush()
    try:
        body = {'values': [values]}
        result = sheets_service.spreadsheets().values().update(
            spreadsheetId=SPREADSHEET_ID, range=range_name,
            valueInputOption='RAW', body=body).execute()
        print(f"DEBUG: Successfully updated {sheet_name} at {range_name}.")
        sys.stdout.flush()
        return result
    except Exception as e:
        print(f"ERROR: Error updating sheet {sheet_name} at {range_name}: {e}")
        traceback.print_exc()
        sys.stdout.flush()
        return None

# --- Employee State Management ---
# Column indices for Employees sheet (0-indexed)
EMPLOYEE_LINE_ID_COL = 0
EMPLOYEE_NAME_COL = 1
EMPLOYEE_POSITION_COL = 2
EMPLOYEE_CURRENT_STATE_COL = 3
EMPLOYEE_CURRENT_TRANSACTION_ID_COL = 4

def get_employee_data(user_id):
    """Retrieves a specific employee's data row from the Employees sheet."""
    employees_data = get_sheet_data("Employees")
    for i, row in enumerate(employees_data):
        if row and len(row) > EMPLOYEE_LINE_ID_COL and row[EMPLOYEE_LINE_ID_COL] == user_id:
            # Ensure the row has enough columns for state and transaction ID
            while len(row) <= EMPLOYEE_CURRENT_TRANSACTION_ID_COL:
                row.append("") # Pad with empty strings if columns are missing
            return row, i + 1 # Return row data and 1-indexed row number
    return None, None

def update_employee_state(user_id, state, transaction_id=None):
    """Updates the current_state and current_transaction_id for an employee."""
    employee_row, row_num = get_employee_data(user_id)
    if employee_row:
        employee_row[EMPLOYEE_CURRENT_STATE_COL] = state
        employee_row[EMPLOYEE_CURRENT_TRANSACTION_ID_COL] = transaction_id if transaction_id is not None else ""
        
        # Update the specific row in Google Sheets
        # Assuming headers are in row 1, data starts from row 2
        range_name = f"Employees!A{row_num}:E{row_num}" # Adjust range based on actual columns
        return update_sheet_data("Employees", range_name, employee_row)
    return None

# --- Location Calculation Helper ---
def haversine_distance(lat1, lon1, lat2, lon2):
    R = 6371000  # Radius of Earth in meters
    phi1 = math.radians(lat1)
    phi2 = math.radians(lat2)
    delta_phi = math.radians(lat2 - lat1)
    delta_lambda = math.radians(lon2 - lon1)

    a = math.sin(delta_phi / 2)**2 + math.cos(phi1) * math.cos(phi2) * math.sin(delta_lambda / 2)**2
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))

    distance = R * c  # Distance in meters
    return distance

# --- Webhook Endpoint ---
@app.route("/callback", methods=['POST'])
def callback():
    # Ensure Google services are initialized
    ensure_google_services()

    print("Webhook callback received!") # Add this line for debugging
    sys.stdout.flush() # Flush output
    signature = request.headers.get('X-Line-Signature') # Use .get() for safety
    if not signature:
        print("ERROR: Missing X-Line-Signature header.")
        sys.stdout.flush()
        abort(400, description="Missing X-Line-Signature")

    body = request.get_data(as_text=True)
    print("Request body: " + body)
    print("X-Line-Signature: " + signature)
    sys.stdout.flush() # Flush output

    try:
        handler.handle(body, signature)
    except InvalidSignatureError as e:
        print("ERROR: Invalid LINE signature. Check LINE_CHANNEL_SECRET.")
        print(f"Exception details: {e}")
        traceback.print_exc()
        sys.stdout.flush()
        abort(400)
    except Exception as e:
        print(f"ERROR: Error handling webhook: {e}")
        print(f"Exception details: {e}")
        traceback.print_exc()
        sys.stdout.flush()
        abort(500)

    return 'OK'

# --- OAuth Routes ---
@app.route('/authorize')
def authorize():
    flow = Flow.from_client_secrets_file(
        CLIENT_SECRETS_FILE, 
        scopes=OAUTH_SCOPES)
    flow.redirect_uri = GOOGLE_REDIRECT_URI

    authorization_url, state = flow.authorization_url(
        access_type='offline',            # Required to get a refresh token
        include_granted_scopes='true',
        prompt='consent'                  # Force consent to reliably obtain refresh_token on first auth
    )
    
    session['oauth_state'] = state
    print(f"DEBUG: set session oauth_state = {state}") # New print
    sys.stdout.flush()
    return redirect(authorization_url)

@app.route('/oauth2callback')
def oauth2callback():
    state = session.get('oauth_state')
    if not state:
        return "Invalid or missing OAuth state. Please start authorization again at /authorize", 400

    print(f"DEBUG: session oauth_state = {session.get('oauth_state')}") # New print
    print(f"DEBUG: query state = {request.args.get('state')}") # New print
    print(f"DEBUG: query code  = {request.args.get('code')}") # New print
    print(f"DEBUG: request url   = {request.url}") # New print
    sys.stdout.flush()

    flow = Flow.from_client_secrets_file(
        CLIENT_SECRETS_FILE, 
        scopes=OAUTH_SCOPES, state=state)
    flow.redirect_uri = GOOGLE_REDIRECT_URI

    authorization_response = request.url
    flow.fetch_token(authorization_response=authorization_response)

    credentials = flow.credentials

    # Save the credentials for the next run
    with open(TOKEN_PATH, 'w') as f:
        f.write(credentials.to_json())
    
    # Now, you can get the folder ID from the user's Drive
    # For simplicity, we'll assume a specific folder name or ID will be set manually after auth.
    # In a real app, you might prompt the user to select a folder or create one.
    # For now, we'll just confirm success.
    return 'Authorization successful! You can close this tab.'

# --- LIFF App Serving Route ---
# @app.route('/liff_location_picker') # Removed LIFF route
# def serve_liff_location_picker():
#     print("DEBUG: Serving liff_location_picker.html")
#     sys.stdout.flush()
#     try:
#         with open('liff_location_picker.html', 'r', encoding='utf-8') as f:
#             html_content = f.read()
#         html_content = html_content.replace("YOUR_LIFF_ID", LIFF_ID)
#         print("DEBUG: liff_location_picker.html served successfully.")
#         sys.stdout.flush()
#         abort(404)
#     except Exception as e:
#         print(f"ERROR: Error serving liff_location_picker.html: {e}")
#         traceback.print_exc()
#         sys.stdout.flush()
#         abort(500)

# --- Message Handler ---
@handler.add(MessageEvent, message=TextMessageContent)
def handle_message(event):
    # Ensure Google services are initialized
    ensure_google_services()

    user_id = event.source.user_id
    text = event.message.text.strip()

    print(f"DEBUG: User ID: {user_id}")
    sys.stdout.flush()

    # Get employee data and state
    employee_data, _ = get_employee_data(user_id)
    current_state = employee_data[EMPLOYEE_CURRENT_STATE_COL] if employee_data else "idle"
    current_transaction_id = employee_data[EMPLOYEE_CURRENT_TRANSACTION_ID_COL] if employee_data else ""

    print(f"DEBUG: User {user_id} current_state: {current_state}, current_transaction_id: {current_transaction_id}")
    sys.stdout.flush()

    if not employee_data: # User not registered
        line_bot_api.reply_message(
            ReplyMessageRequest(
                reply_token=event.reply_token,
                messages=[V3TextMessage(text="กรุณาลงทะเบียนก่อนใช้งานฟังก์ชันนี้")]
            )
        )
        print("DEBUG: Replied: กรุณาลงทะเบียนก่อนใช้งานฟังก์ชันนี้ (Image)...")
        sys.stdout.flush()
        return

    if current_state == "waiting_for_checkin_images" and current_transaction_id:
        try:
            # Get image content from LINE
            resp = blob_api.get_message_content(message_id)
            # Robust handling of resp (streaming or bytes)
            if hasattr(resp, "iter_content"):
                image_bytes = b"".join(chunk for chunk in resp.iter_content(chunk_size=1024))
            elif isinstance(resp, (bytes, bytearray)):
                image_bytes = bytes(resp)
            elif hasattr(resp, "read"):
                image_bytes = resp.read()
            else:
                image_bytes = bytes(resp)

            # Detect image type and MIME using Pillow (imghdr removed in Python 3.13)
            with Image.open(io.BytesIO(image_bytes)) as im:
                fmt = (im.format or "").lower()  # e.g., 'jpeg', 'png', 'gif', 'webp'
            
            # Prevent upload if image format is unknown
            if not fmt:
                line_bot_api.reply_message(
                    ReplyMessageRequest(
                        reply_token=event.reply_token,
                        messages=[V3TextMessage(text="ขออภัยครับ ไม่สามารถระบุชนิดของไฟล์รูปภาพที่คุณส่งมาได้ กรุณาส่งไฟล์รูปภาพที่ถูกต้อง (JPEG, PNG, GIF)")]
                    )
                )
                print("DEBUG: Replied: ไม่สามารถระบุชนิดของไฟล์รูปภาพ...")
                sys.stdout.flush()
                return # Stop upload

            ext = "jpg" if fmt == "jpeg" else (fmt or "bin")
            mime = f"image/{'jpeg' if ext == 'jpg' else ext}" if fmt else "application/octet-stream"
            file_name = f"checkin_image_{current_transaction_id}_{uuid.uuid4()}.{ext}"

            # Upload non-resumable from memory
            bio = io.BytesIO(image_bytes)
            media = MediaIoBaseUpload(bio, mimetype=mime, resumable=False)

            file_metadata = {
                'name': file_name,
                'parents': [GOOGLE_DRIVE_FOLDER_ID] # Use GOOGLE_DRIVE_FOLDER_ID from .env
            }
            
            uploaded_file = drive_service.files().create(body=file_metadata, media_body=media, fields='id,webViewLink', supportsAllDrives=True).execute()
            image_url = uploaded_file.get('webViewLink')
            print(f"DEBUG: Image uploaded to Drive: {image_url}")
            sys.stdout.flush()

            # Set public permission for the uploaded file
            drive_service.permissions().create(
                fileId=uploaded_file['id'],
                body={'type': 'anyone', 'role': 'reader'},
                supportsAllDrives=True
            ).execute()
            print("DEBUG: Image permission set to public.")
            sys.stdout.flush()

            # Update CheckIns sheet with image URL
            checkins_data = get_sheet_data("CheckIns")
            updated = False
            for i, row in enumerate(checkins_data):
                if row and len(row) > 0 and row[0] == current_transaction_id:
                    # Find the next available image_url column (image_url_1, image_url_2, image_url_3)
                    for j in range(5, 8): # Columns 5, 6, 7 (0-indexed) for image_url_1, 2, 3
                        if len(row) <= j or not row[j]: # If column doesn't exist or is empty
                            # Ensure row has enough columns
                            while len(row) <= j:
                                row.append("")
                            row[j] = image_url
                            updated = True
                            # Update the specific row in Google Sheets
                            range_name = f"CheckIns!A{i+1}:H{i+1}" # Adjust range based on actual columns
                            update_sheet_data("CheckIns", range_name, row)
                            break
                    if updated:
                        break
            
            # Count images for this transaction to decide state update
            images_now = 0
            # Re-read the updated row to be sure (or pass it from previous update_sheet_data call)
            # For simplicity, re-reading here. In a real app, optimize this.
            checkins_data_after_update = get_sheet_data("CheckIns")
            for row_after_update in checkins_data_after_update:
                if row_after_update and row_after_update[0] == current_transaction_id:
                    for j in range(5, 8):  # F..H = image_url_1..3
                        if j < len(row_after_update) and row_after_update[j]:
                            images_now += 1
                    break

            if images_now >= 3: # If 3 or more images are uploaded, reset state
                update_employee_state(user_id, "idle", "")
                line_bot_api.reply_message(
                    ReplyMessageRequest(
                        reply_token=event.reply_token,
                        messages=[V3TextMessage(text="บันทึกรูปภาพหลักฐานครบถ้วนแล้ว\nคุณสามารถดำเนินการอื่นต่อได้")]
                    )
                )
                print("DEBUG: Replied: บันทึกรูปภาพหลักฐานครบถ้วนแล้ว...")
                sys.stdout.flush()
            else:
                line_bot_api.reply_message(
                    ReplyMessageRequest(
                        reply_token=event.reply_token,
                        messages=[V3TextMessage(text="บันทึกรูปภาพหลักฐานเรียบร้อยแล้ว\nคุณสามารถส่งรูปภาพเพิ่มเติมได้อีก (สูงสุด 3 รูป) หรือส่งข้อความอื่นเพื่อดำเนินการต่อ")]
                )
            )
            print("DEBUG: Replied: บันทึกรูปภาพหลักฐานเรียบร้อยแล้ว...")
            sys.stdout.flush()

        except Exception as e:
            print(f"ERROR: Error handling image message: {e}")
            traceback.print_exc()
            sys.stdout.flush()
            line_bot_api.reply_message(
                ReplyMessageRequest(
                    reply_token=event.reply_token,
                    messages=[V3TextMessage(text="เกิดข้อผิดพลาดในการบันทึกรูปภาพ กรุณาลองใหม่อีกครั้ง")]
                )
            )
            print("DEBUG: Replied: เกิดข้อผิดพลาดในการบันทึกรูปภาพ...")
            sys.stdout.flush()

    else:
        line_bot_api.reply_message(
            ReplyMessageRequest(
                reply_token=event.reply_token,
                messages=[V3TextMessage(text="กรุณาเช็คอินก่อนส่งรูปภาพ")]
            )
        )
        print("DEBUG: Replied: กรุณาเช็คอินก่อนส่งรูปภาพ...")
        sys.stdout.flush()

# --- Main execution ---
if __name__ == '__main__':
    # Initialize services explicitly
    sheets_service = get_google_service_sheets()
    drive_service = get_drive_service_oauth()

    if sheets_service:
        print("Sheets service ready.")
    else:
        print("Sheets service NOT ready. Check GOOGLE_SHEET_ID and credentials.")

    if drive_service:
        print("Drive service ready (OAuth).")
    else:
        print("Drive service NOT authorized. Please visit /authorize to connect Google Drive.")

    sys.stdout.flush()

    app.run(host='0.0.0.0', port=8000)
# Last updated: 2025-08-14 09:30:00
